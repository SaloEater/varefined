--[[

AYYKYU'S VOICED ACTOR FRAMEWORK V1.0
Russian sound pack compiled and edited by DesmanMetzger
edits and additonal soundtriggers (thirst/hunger/sleep) by Dhatri

allows you to make your actor speak and react with the use of a simple function which does most of the audio work for you

just place "ayykyu_voiced_actor.actor_speak(file,sound_volume,cooldown,chance,requires_squad,has_priority,ignore_conditionals,is_state)" in your code, provide a correct filename and flags - the function will run through all the rules to make sure the sound should be played and if it succeeds, a cooldown will be applied before the next sound is able to play, to provide natural pauses and to avoid too many sounds going off at the same time

file should be in string format, example: "actor\\pain1"
you can use math.random() to play randomised sounds, example: "actor\\pain" .. math.random(4)

sound_volume controls how loud the sound should be
1.0 is normal volume, 0.0 is silent

cooldown value is the time that needs to pass before the next sound can be played
1000 = 1 second

chance is the probability of this instance of actor_speak() to play its sound, chance/100

requires_squad checks if player has a squad and if they're close enough to "hear" each other

has_priority allows this call to ignore the cooldown
previously started and on-going voiceline will be stopped

ignore_conditionals allows this call to play even if the actor is talking or is dead
useful for reaction sounds, like death or pain
you can add your own conditionals by adding them between the brackets in the line with the check, use "or" between the rules

is_state indicates that this is going to be a state sound
these sounds use a separate timer and don't interfere with the main sound stream, useful for something that can be interrupted by anything

if you use this file's functions outside of it, don't forget to put "ayykyu_voiced_actor." in front of them, otherwise your engine instance WILL CRASH
don't add "ayykyu_voiced_actor." if your code is executed here

this file has various debug values and messages to help troubleshoot issues or inconsistencies, remove the "--DEBUG--" parts of lines to enable them
"printf" logs things to the console, "SetHudMsg" displays them on the screen, you can only have one SetHudMsg active

combat_inertia = 1 --is set later, helps the combat status last for a while after enemies stopped targeting the actor
DEBUG--local actor_in_combat = "no" --debug value, "remembers" if actor is in combat for later use in HUD messages

------------------------------------------------------------------------------------

Dhatri and Grok's Edits

Now actor will have voice lines related to thirstiness and hunger (associated with HUD icons appearing).

An option, defined just below, will play muffled sounds. If such sounds are not available, replace

muffle = "m_"

by

muffle = ""

------------------------------------------------------------------------------------

Werwolf's Edits

Additional voice lines and conditions with GAMMA weights
--]]
local get_config = varefined_mcm.get_config

--[[
    Structure of a lines_by_language entry:
    ["language_key"] ="the prefix for the line in the file name, for example _eng for english"
]]
local ini = ini_file_ex("plugins\\varefined.ltx")
language_prefixes = {
    ["rus"] = nil,
    ["eng"] = nil
}
function init_languages()
    printf("i")
    local languages = ini:collect_section("language")
    for lang_key, value in pairs(languages) do
        language_prefixes[lang_key] = value
        printf("Language %s has prefix: %s", lang_key, language_prefixes[lang_key])
    end
end

local combat_inertia = 0

lang = "rus" -- initiates actor language condition

function get_actor_lang()
    if get_config("voice_language") == 0 then
        local faction = get_actor_true_community()
        if faction == "isg" or faction == "killer" then
            lang = "eng"
        else
            lang = "rus"
        end
        return lang
    elseif get_config("voice_language") == 1 then
        lang = "rus"
        return lang
    else
        lang = "eng"
        return lang
    end
end

muffle = "" -- initiates muffling condition

function get_muffle_status()
    -- changes muffle condition of the sound
    if not get_config("enable_muffled_shouts") then
        muffle = ""
        return muffle
    end
    local helmet = (db.actor:item_in_slot(12))
    if helmet then
        muffle = "m_"
    else
        muffle = ""
    end
    return muffle
end

function check_for_weapon(target)
    -- this function checks if an npc has a weapon, prevents unarmed stalkers from counting as enemies, can be used externally

    if IsStalker(target) then
        -- checks if target is human
        local target_item = target:active_item() -- gets their active item
        if target_item and IsWeapon(target_item) then
            -- checks if the item exists and is a weapon
            return true
        else
            return false
        end
    else
        -- if an npc is not human, it is a mutant, which means it doesn't need a weapon to attack, so we return true here
        return true
    end

end

function is_actor_in_combat()
    -- INNER combat checker, returns true if actor is being TARGETED by an npc (both stalkers and mutants count) FROM DISTANCE NOT GREATER THAN 70m , false if not, can be used externally

    --	NOTE: I REMOVED REQUIRMENT FOR WEAPON ,BECAUSE BY MY LOGIC ,ENEMY IS ENEMY ,NO MATTER IF HE HAVE WEAPON IN HANDS OR NOT ,BUT IF YOU WANT TURN ON THIS CONDITION AGAIN
    --		JUST REPLACE LINE 69 WITH  "if npc and npc:alive() and check_for_weapon(npc) == true and npc:position():distance_to(db.actor:position())<=70"  WITHOUT QUOTES

    for id, v in pairs(xr_combat_ignore.fighting_with_actor_npcs) do
        -- gets internal info
        local npc = db.storage[id] and db.storage[id].object -- gets internal info
        if npc and npc:alive() == true and npc:position():distance_to(db.actor:position()) <= 70 then
            -- checks if there's a TARGETING npc, if it is alive and if it is close enough
            -- DEBUG--			actor_in_combat = "yes, actively targeted" --actor is being targeted right now
            combat_inertia = time_global() + 10000 -- sets the delay of ten seconds to ensure that combat status doesn't drop in case enemies stop targeting the actor for a short time
            return true -- returns true if all conditions are met
        elseif time_global() < combat_inertia then
            -- main combat check failed, so now we check if "inertia" is still there
            -- DEBUG--			actor_in_combat = "yes, not actively targeted" --nobody is targeting the actor, but inertia is true
            return true
        else
            -- actor is not in combat and inertia has expired
            -- DEBUG--			actor_in_combat = "no"
            return false
        end
    end
end

function outer_combat_checker()
    -- OUTER COMBAT CHECKER ,ITS EXACTLY THE SAME AS ABOVE FUNCTION ,BUT FOR DISTANCE FROM 70m TO 140m
    for id, v in pairs(xr_combat_ignore.fighting_with_actor_npcs) do
        local npc1 = db.storage[id] and db.storage[id].object
        if is_actor_in_combat() == true then
            -- ADDED CONDITION TO ENSURE THAT INNER COMBAT PERIMETER WILL HAVE HIGHER PRIORITY AND MOST IMPORTANT TO ENSURE THAT SOUNDS FOR INNER AND OUTER PERIMETER WILL NOT PLAY SIMULTANEOUSLY IF CHARACTER WILL BE IN FIGHT WITH ENEMIES FROM BOTH PERIMETERS
            return false
        elseif npc1 and npc1:alive() == true and npc1:position():distance_to(db.actor:position()) > 70 and
                npc1:position():distance_to(db.actor:position()) < 140 then
            combat_inertia = time_global() + 10000
            return true
        elseif time_global() < combat_inertia then
            return true
        else
            return false
        end
    end
end

function squad_near()
    -- CHECKS IF THERE IS A SQUAD IN NEAR DISTANCE ( "NORMAL VOLUME SPEECH HEARING DISTANCE" ) ,MEANS UP TO 24m
    local i, xv = next(axr_companions.companion_squads, nil) -- GETS INFO ABOUT COMPANIONS
    local commander = xv and alife_object(xv:commander_id())
    if (not (xv) or commander and commander.position:distance_to(db.actor:position()) > 24) then
        -- CHECKS IF THERE IS A SQUAD AND IF ITS CLOSE ENOUGH
        return false -- IF THERE IS NO SQUAD OR SQUAD IS NOT CLOSE ENOUGH GIVE FALSE VALUE
    elseif commander.position:distance_to(db.actor:position()) <= 24 then
        -- IF THERE IS A SQUAD THEN CHECKS DISTANCE
        return true -- IF CONDITIONS ARE MET IT RETURNS TRUE
    else
        -- IF CONDITIONS ARE NOT MET IT RETURNS FALSE
        return false
    end
end

function squad_can_hear()
    -- SAME AS ABOVE FUNCTION BUT FOR HEARING DISTANCE ( "LOUD VOLUME SPEECH HEARING DISTAMCE" ),MEANS MAX. 60m
    local i, yv = next(axr_companions.companion_squads, nil)
    local commander = yv and alife_object(yv:commander_id())
    if (not (yv) or commander.position:distance_to(db.actor:position()) <= 24 or
            commander.position:distance_to(db.actor:position()) > 60) then
        return false
    elseif commander.position:distance_to(db.actor:position()) > 24 and
            commander.position:distance_to(db.actor:position()) <= 60 then
        return true
    else
        return false
    end
end

function squad_out()
    -- SAME AS ABOVE FUNCTIONS BUT FOR OUT OF HEARING DISTANCE (MORE THAN 60m)
    local i, zv = next(axr_companions.companion_squads, nil)
    local commander = zv and alife_object(zv:commander_id())
    if (not (zv) or commander.position:distance_to(db.actor:position()) > 60) then
        return true
    else
        return false
    end
end

local speaking_cooldown = 0 -- is set later
local state_cooldown = 0 -- is set later
local file_to_say = nil -- is set later
local mcm_sound_volume = get_config("shouts_volume") -- gets the volume value from MCM

function actor_speak_default(file, sound_volume, cooldown, max_chance)
    actor_speak(file, sound_volume, cooldown, max_chance, false, false, false, false, false, false)
end

function actor_speak_default_ignore_conditionals(file, sound_volume, cooldown, max_chance)
    actor_speak(file, sound_volume, cooldown, max_chance, false, false, false, false, true, false)
end

function actor_speak_default_state(file, sound_volume, cooldown, max_chance)
    actor_speak(file, sound_volume, cooldown, max_chance, false, false, false, false, false, true)
end

function actor_speak_with_priority_ignore_conditionals(file, sound_volume, cooldown, max_chance)
    actor_speak(file, sound_volume, cooldown, max_chance, false, false, false, true, true, false)
end

function actor_speak_squad_near(file, sound_volume, cooldown, max_chance)
    actor_speak(file, sound_volume, cooldown, max_chance, true, false, false, false, false, false)
end

function actor_speak_squad_can_hear(file, sound_volume, cooldown, max_chance)
    actor_speak(file, sound_volume, cooldown, max_chance, false, true, false, false, false, false)
end

function actor_speak_squad_out(file, sound_volume, cooldown, max_chance)
    actor_speak(file, sound_volume, cooldown, max_chance, false, false, true, false, false, false)
end

function actor_speak(file, sound_volume, cooldown, chance, requires_squad_near, requires_squad_can_hear,
                     requires_squad_out, has_priority, ignore_conditionals, is_state)
    -- (EDITED FUCTION  - ADDED SOME REQUIREMENTS) player function, plays the sound if all conditions are met. Argument "sound_volume" is overwriten by default from MCM shouts volume slider.
    printf("file to say: %s", file)
    if file == nil then
        return
    end

    if is_state == true then
        has_priority = false
    end -- forces has_priority to be false if this is a state sound

    if not db.actor then
        return
    end -- this checks if actor exists
    if is_state == true and time_global() < state_cooldown then
        return
    end -- checks if this call is meant to play a state sound
    if is_state == false and has_priority == false and time_global() < speaking_cooldown then
        return
    end -- this checks for the cooldown, unless has_priority or is_state is true
    if ignore_conditionals == false and (db.actor:is_talking() or not db.actor:alive()) then
        return
    end -- checks if the actor is talking or is dead, unless ignore_conditionals is true
    local max_chance = math.random(1, 100) -- sets the max_chance value to compare chance with
    if chance < max_chance then
        return
    end -- does the comparasion
    if requires_squad_near == true and squad_near() == false then
        return
    end -- ADDED REQUIREMENT FOR SQUAD IN "NORMAL VOLUME SPEECH HEARING DISTANCE"
    if requires_squad_can_hear == true and squad_can_hear() == false then
        return
    end -- ADDED REQUIREMENT FOR SQUAD IN "LOUD VOLUME SPEECH HEARING DISTAMCE"
    if requires_squad_out == true and squad_out() == false then
        return
    end -- ADDED REQUIREMENT FOR SQUAD OUT OF HEARING DISTANCE

    if file_to_say then
        -- makes sure there's a sound to stop
        file_to_say:stop() -- stops whatever was called through this function before
    end

    -- DEBUG--	printf("sound volume: " .. sound_volume) --prints out the volume of the sound to the console log, debug purposes

    file_to_say = sound_object(file) -- sets the file to play
    file_to_say:play(db.actor, 0, sound_object.s2d) -- plays it
    if mcm_sound_volume then
        file_to_say.volume = mcm_sound_volume * sound_volume
    else
        file_to_say.volume = sound_volume -- sets how loud the sound should be
    end

    -- DEBUG--	printf("actor sound played: " .. file) --prints out played files to the console log, debug purposes

    state_cooldown = time_global() + cooldown -- applies the state cooldown, so that state sounds obey main cooldowns
    if is_state == false then
        speaking_cooldown = time_global() + cooldown -- applies the main cooldown
    end

end

function sound_check()
    -- SMALL FUNCTION THAT ONLY CHECKS IF SOUND CALLED BY THIS SCRIPT IS PLAYED RIGHT NOW ,THIS FUNCTION IS FOR USE FROM VOICED COMMANDS (axr_companions.script) AND WILL STOP ANY SOUND CALLED BY THIS SCRIPT TO ENSURE THAT SOUNDS CALLED BY BOTH SCRIPTS WILL NOT PLAY SIMULTANEOUSLY AND COMMANDS WILL HAVE HIGHEST PRIORITY
    if file_to_say then
        file_to_say:stop()
    end
end

local combat_intensity = 0 -- main value that drives the combat status system
local combat_intensity_drain_cooldown = 0 -- auxilary value, prevents combat progression from draining constantly, instead it only drains after nothing combat-related happens for some time
local combat_medium_threshold = 600 -- the threshold at which combat status switches to it's second phase
local combat_high_threshold = 1200 -- the threshold at which combat status switches to it's final third phase (combat_intensity value doesn't stop there and can progress even further, but that won't have any changes)

-- intensity dictates how much should we add to the combat status progression
-- intensity_add_limit sets the point after which this action won't add any intensity, uses combat_high_threshold as its "maximum"
-- cooldown tells how much time should we add to the pause before the actor will start "calming down", 100 = approx. one second, capped at ten seconds

-- you can also use negative values for intensity and cooldown to reduce them, don't do that with intensity_add_limit though

function add_action_intensity(intensity, intensity_add_limit, cooldown)
    -- universal function for progressing combat phases, can be used externally

    if combat_intensity < (combat_high_threshold * intensity_add_limit) then
        -- checks if we can add intensity according to intensity_add_limit
        combat_intensity = combat_intensity + intensity -- adds it
    end
    combat_intensity_drain_cooldown = combat_intensity_drain_cooldown + cooldown -- adds the cooldown even if we didn't add intensity

end

local LANG_SECTION_FORMAT = "lines_%s"
function get_lines_amount_for_line(line, lang_key)
    return ini:r_value(string.format(LANG_SECTION_FORMAT, lang_key), line, 2, 0)
end

-- format is characters_voice\[category][language]\[subcategory]\[muffle][line]_[line_index]
local VOICE_FORMAT = "characters_voice\\%s%s\\%s\\%s%s_%d"
local VOICE_CATEGORY_PLAYER = "player"
local VOICE_CATEGORY_BUTTON_COMMENTS = "buttoncomments"
local VOICE_CATEGORY_RANDOM_SHOUTS = "random_shouts"
local VOICE_CATEGORY_COMMANDS = "commands"
local VOICE_CATEGORY_DIALOGS = "dialogs"
local VOICE_CATEGORY_SQUAD = "squad"

function random_voice_line_and_subcategory_same(category, language_key, muffle_val, line)
    return random_voice_line(category, line, language_key, muffle_val, line)
end

function get_lines_amount_for_line_for_current_lang(line)
    return get_lines_amount_for_line(line, lang)
end

function random_voice_line(category, subcategory, language_key, muffle_val, line)
    local lines = get_lines_amount_for_line(line, language_key)
    if lines == 0 then
        printf("no lines found for line %s, language %s, category %s, subcategory %s, muffle %s", line, language_key, category,
                subcategory, muffle_val)
        return nil
    end

    if language_prefixes == nil or next(language_prefixes) == nil then
        init_languages()
    end

    return string.format(VOICE_FORMAT, category, language_prefixes[language_key], subcategory, muffle_val, line, math.random(lines))
end

function player_with_lang_muffle_random(category)
    return random_voice_line_and_subcategory_same(VOICE_CATEGORY_PLAYER, lang, muffle, category)
end
function button_comments_with_lang_muffle_random(category)
    return random_voice_line_and_subcategory_same(VOICE_CATEGORY_BUTTON_COMMENTS, lang, muffle, category)
end
function random_shout_with_lang_muffle_random(category)
    return random_voice_line_and_subcategory_same(VOICE_CATEGORY_RANDOM_SHOUTS, lang, muffle, category)
end
function commands_with_lang_muffle(category, line)
    return random_voice_line(VOICE_CATEGORY_COMMANDS, category, lang, muffle, line)
end
function dialogs_with_lang_muffle(category)
    return random_voice_line_and_subcategory_same(VOICE_CATEGORY_DIALOGS, lang, muffle, category)
end
function squad_with_lang_muffle(category)
    return random_voice_line_and_subcategory_same(VOICE_CATEGORY_SQUAD, lang, muffle, category)
end

function monster_on_death_callback(victim, killer)
    -- (EDITED FUNCTION - ADDED MORE CALLBACKS) adds combat_intensity when a mutant is killed

    if not db.actor:alive() then
        return
    end -- don't do anything if actor is dead
    if not killer then
        return
    end -- abort the function if there's no killer
    if killer:id() ~= db.actor:id() then
        return
    end -- make sure that it's the actor who scored the kill
    if db.actor:is_talking() then
        return
    end
    if not get_config("enable_on_kill_shouts") then
        return
    end -- filters disabled kill shouts from MCM

    --	if is_actor_in_combat() == false then return end   --auxialry rule, checks if actor is in combat before doing anything (remove the "--" at the start of the line to enable it)
    --	if (not db.actor:see(victim)) then return end   --extra condition, makes sure that actor saw the npc die

    if axr_companions.sound_checking() == true then
        return
    end -- CHECKS IF VOICED COMMAND IS CURRENTLY PLAYED AND IF YES ,IT WILL STOP FUNCTION SO IT WILL NOT INTERRUPT ANY COMMAND
    local actor_in_combat = is_actor_in_combat()
    local outer_combat = outer_combat_checker()
    if actor_in_combat == true and combat_intensity > combat_high_threshold and math.random(1, 100) < 40 then
        actor_speak_default(player_with_lang_muffle_random(choose_random_category("kill_confirm_common_state3", "kill_confirm_mutant_state3")),
                1.0, 3500, 70)
    elseif actor_in_combat == true and combat_intensity > combat_medium_threshold and math.random(1, 100) < 40 then
        actor_speak_default(player_with_lang_muffle_random(choose_random_category("kill_confirm_common_state2", "kill_confirm_mutant_state2")),
                1.0, 3500, 55)
    elseif actor_in_combat == true and math.random(1, 100) < 40 then
        actor_speak_squad_near(player_with_lang_muffle_random(choose_random_category("kill_confirm_common_squad", "kill_confirm_mutant_squad")),
                1.0, 2000, 40)
        actor_speak_squad_can_hear(player_with_lang_muffle_random(choose_random_category("kill_confirm_common_squad", "kill_confirm_mutant_squad")),
                1.0, 2000, 40)
        actor_speak_squad_out(player_with_lang_muffle_random(choose_random_category("kill_confirm_common_state1", "kill_confirm_mutant_state1")),
                1.0, 2000, 40)
    elseif outer_combat == true and combat_intensity > combat_high_threshold and math.random(1, 100) < 40 then
        actor_speak_squad_near(player_with_lang_muffle_random(choose_random_category("kill_confirm_common_squad", "kill_confirm_mutant_squad")),
                1.0, 2000, 50)
        actor_speak_squad_can_hear(player_with_lang_muffle_random(choose_random_category("kill_confirm_common_squad", "kill_confirm_mutant_squad")),
                1.0, 2000, 50)
        actor_speak_squad_out(player_with_lang_muffle_random(choose_random_category("kill_comment_common_state3", "kill_comment_mutant_state3")),
                1.0, 2000, 50)
    elseif outer_combat == true and combat_intensity > combat_medium_threshold and math.random(1, 100) < 40 then
        actor_speak_squad_near(player_with_lang_muffle_random(choose_random_category("kill_comment_common_squad", "kill_comment_mutant_squad")),
                1.0, 1500, 40)
        actor_speak_squad_can_hear(player_with_lang_muffle_random(choose_random_category("kill_comment_common_state2", "kill_comment_mutant_state2")),
                1.0, 2000, 40)
        actor_speak_squad_out(player_with_lang_muffle_random(choose_random_category("kill_comment_common_state2", "kill_comment_mutant_state2")),
                1.0, 2000, 40)
    elseif outer_combat == true and math.random(1, 100) < 40 then
        actor_speak_default(player_with_lang_muffle_random(choose_random_category("kill_comment_common_state1", "kill_comment_mutant_state1")),
                1.0, 2000, 25)
    elseif not (actor_in_combat) and not (outer_combat) and math.random(1, 100) < 40 then
        actor_speak_default(player_with_lang_muffle_random(choose_random_category("kill_comment_common_state1", "kill_comment_mutant_state1")),
                1.0, 2000, 25)
    end

    add_action_intensity(80, 1.0, 1000)

end

function npc_on_death_callback(victim, killer)
    -- (EDITED FUNCTION - ADDED MORE CALLBACKS) adds combat_intensity when a human is killed, just go read the previous function for info, it's exactly the same, but for humans

    if not db.actor:alive() then
        return
    end
    if db.actor:is_talking() then
        return
    end

    if dialogs_axr_companion.is_actor_companion(db.actor, victim) then
        actor_speak_default(squad_with_lang_muffle("squadmate_died"), 1.0, 3500, 100)
    end

    if not killer then
        return
    end
    if killer:id() ~= db.actor:id() then
        return
    end
    if not get_config("enable_on_kill_shouts") then
        return
    end -- filters disabled kill shouts from MCM

    --	if is_actor_in_combat() == false then return end
    --	if (not db.actor:see(victim)) then return end

    if axr_companions.sound_checking() == true then
        return
    end
    local actor_in_combat = is_actor_in_combat()
    local outer_combat = outer_combat_checker()
    if actor_in_combat == true and combat_intensity > combat_high_threshold and math.random(1, 100) < 40 then
        actor_speak_default(player_with_lang_muffle_random(choose_random_category("kill_confirm_common_state3", "kill_confirm_stalker_state3")),
                1.0, 3500, 80)
    elseif actor_in_combat == true and combat_intensity > combat_medium_threshold and math.random(1, 100) < 40 then
        actor_speak_default(player_with_lang_muffle_random(choose_random_category("kill_confirm_common_state2", "kill_confirm_stalker_state2")),
                1.0, 3500, 65)
    elseif actor_in_combat == true then
        actor_speak_squad_near(player_with_lang_muffle_random(choose_random_category("kill_confirm_common_squad", "kill_confirm_stalker_squad")),
                1.0, 2000, 50)
        actor_speak_squad_can_hear(player_with_lang_muffle_random(choose_random_category("kill_confirm_common_squad", "kill_confirm_stalker_squad")),
                1.0, 2000, 50)
        actor_speak_squad_out(player_with_lang_muffle_random(choose_random_category("kill_confirm_common_state1", "kill_confirm_stalker_state1")),
                1.0, 2000, 50)
    elseif outer_combat == true and combat_intensity > combat_high_threshold and math.random(1, 100) < 40 then
        actor_speak_squad_near(player_with_lang_muffle_random(choose_random_category("kill_confirm_common_squad", "kill_confirm_stalker_squad")),
                1.0, 2000, 65)
        actor_speak_squad_can_hear(player_with_lang_muffle_random(choose_random_category("kill_confirm_common_squad", "kill_confirm_stalker_squad")),
                1.0, 2000, 65)
        actor_speak_squad_out(player_with_lang_muffle_random(choose_random_category("kill_comment_common_state3", "kill_comment_stalker_state3")),
                1.0, 2500, 65)
    elseif outer_combat == true and combat_intensity > combat_medium_threshold and math.random(1, 100) < 40 then
        actor_speak_squad_near(player_with_lang_muffle_random(choose_random_category("kill_comment_common_squad", "kill_comment_stalker_squad")),
                1.0, 1500, 40)
        actor_speak_squad_can_hear(player_with_lang_muffle_random(choose_random_category("kill_comment_common_state2", "kill_comment_stalker_state2")),
                1.0, 2000, 40)
        actor_speak_squad_out(player_with_lang_muffle_random(choose_random_category("kill_comment_common_state2", "kill_comment_stalker_state2")),
                1.0, 2000, 40)
    elseif outer_combat == true then
        actor_speak_default(player_with_lang_muffle_random(choose_random_category("kill_comment_common_state1", "kill_comment_stalker_state1")),
                1.0, 2000, 35)
    elseif not (actor_in_combat) and not (outer_combat) and math.random(1, 100) < 40 then
        actor_speak_default(player_with_lang_muffle_random(choose_random_category("kill_comment_common_state1", "kill_comment_stalker_state1")),
                1.0, 2500, 35)
    end

    add_action_intensity(100, 1.0, 1000)

end

function monster_on_hit_callback(npc, damage_amount, local_direction, attacker, bone_index)
    -- adds intensity when a mutant is hit by the actor

    if not db.actor:alive() then
        return
    end -- we don't need this if actor is dead
    if not attacker then
        return
    end -- if there's no attacker, stop the function
    if attacker:id() ~= db.actor:id() then
        return
    end -- check if it's the actor who scored the hit
    --	if is_actor_in_combat() == false then return end --only add the values if actor is in combat

    add_action_intensity(25, 1.0, 100)

end

function npc_on_hit_callback(npc, damage_amount, local_direction, attacker, bone_index)
    -- adds intensity when a human is hit by the actor, same as the previous previous function

    if not attacker then
        return
    end
    if not db.actor:alive() then
        return
    end

    if dialogs_axr_companion.is_actor_companion(db.actor, npc) then
        actor_speak_default(squad_with_lang_muffle("squadmate_hit"), 1.0, 3500, 100)
    end

    if attacker:id() ~= db.actor:id() then
        return
    end
    --	if is_actor_in_combat() == false then return end

    add_action_intensity(25, 1.0, 100)

end

local combat_check_time = 0 -- is set later

delay = 500
grok_delay = 0
function actor_on_update(binder, delta)
    -- thinker function, handles conditional sounds
    tg = time_global()

    if (tg > grok_delay) then
        grok_delay = tg + delay

        get_actor_lang()
        get_muffle_status()

        -- DEBUG--	SetHudMsg("Combat Intensity: " .. combat_intensity .. ", Cooldown: " .. combat_intensity_drain_cooldown .. ", In Combat: " .. actor_in_combat) --draws current combat info

        if not db.actor:alive() then
            return
        end -- stops the thinker from thinking if actor is dead

        if time_global() > combat_check_time then
            -- checks if actor is in combat every five seconds, is used for consistency with combat detection
            is_actor_in_combat()
            combat_check_time = time_global() + 5000 -- adds five seconds of delay
        end

        if combat_intensity_drain_cooldown == 0 and combat_intensity > 0 then
            -- drains combat intensity if there's no cooldown
            combat_intensity = combat_intensity - 1
        end
        if combat_intensity_drain_cooldown > 0 then
            -- constantly drains the cooldown value
            combat_intensity_drain_cooldown = combat_intensity_drain_cooldown - 2
        end

        -- utils.clamp = clamp

        combat_intensity = clamp(combat_intensity, 0, combat_high_threshold * 2) -- keeps combat intensity value in bounds, it shouldn't go into negatives nor overshoot the max cap
        combat_intensity_drain_cooldown = clamp(combat_intensity_drain_cooldown, 0, 1000) -- same thing but for the cooldown

        local hurt_volume = (1 - db.actor.health - (db.actor.health * 0.5)) -- sets the volume of the next hurt sound, gets louder the less health the actor has
        local hurt_pause = 40000 * db.actor.health -- sets the pause before the next hurt sound, it gets shorter the less health the actor has
        local sprint_volume = (1 - db.actor.power - (db.actor.power * 0.5)) -- sets the volume of the next exhaustion sound, gets louder the less stamina the actor has
        local sprint_pause = 12000 * db.actor.power -- sets the pause before the next exhaustion sound, it gets shorter the less stamina the actor has
        local psy_volume = (1 - arszi_psy.get_psy_health() - (arszi_psy.get_psy_health() * 0.5)) -- sets the volume of the next psy sound, gets louder the less psy-health the actor has
        local sanity_pause = (7000 * arszi_psy.get_psy_health()) -- sets the pause before the next psy sound, it gets shorter the less psy-health the actor has
        local fear_pause = (20000 * arszi_psy.get_psy_health()) -- sets the pause before the next psy sound, it gets shorter the less psy-health the actor has
        local thirst_volume = (actor_status_thirst.get_water_deprivation(true) * 0.2)
        local thirst_pause = 65000 / (actor_status_thirst.get_water_deprivation(true) * 0.5)
        local satiety_volume = (1 - db.actor:cast_Actor():conditions():GetSatiety() -
                (db.actor:cast_Actor():conditions():GetSatiety() * 0.5))
        local satiety_pause = 96000 * db.actor:cast_Actor():conditions():GetSatiety()
        local sleep_volume = (actor_status_sleep.get_sleep_deprivation(true) * 0.2)
        local sleep_pause = 120000 / (actor_status_sleep.get_sleep_deprivation(true) * 0.5)
        hurt_pause = clamp(hurt_pause, 40000, 45000) -- limits the hurt_pause value so the pause between sounds isn't too short or too long
        sprint_pause = clamp(sprint_pause, 12000, 12500) -- limits the sprint_pause value so the pause between sounds isn't too short or too long
        sanity_pause = clamp(sanity_pause, 7000, 8000)
        fear_pause = clamp(fear_pause, 20000, 25000) -- limits the psy_pause value so the pause between sounds isn't too short or too long
        thirst_pause = clamp(thirst_pause, 65000, 95000) -- new thirst clamp
        satiety_pause = clamp(satiety_pause, 96000, 108000) -- new satiety clamp, set to long rn, more testing and soundcarpet needed
        sleep_pause = clamp(sleep_pause, 120000, 160000)

        -- state sounds are played in their own priority order
        -- they are checked one by one and the next state sound will attempt to play only if conditions for the previous one weren't met

        if db.actor:is_talking() then
            return
        end
        if axr_companions.sound_checking() == true then
            return
        end -- CHECKS IF VOICED COMMAND IS CURRENTLY PLAYED AND IF YES ,IT WILL STOP FUNCTION SO IT WILL NOT INTERRUPT ANY COMMAND
        if db.actor.health < 0.25 and hurt_volume > 0 then
            -- critically hurt state sound has the highest priority and will always play over any other state sound
            actor_speak_default_state(player_with_lang_muffle_random("hurt_bad"),
                    hurt_volume * 0.66, hurt_pause, 100) -- plays the critically wounded sound

        elseif arszi_psy.get_psy_health() < 0.4 and psy_volume > 0 then
            -- new citically psy-hurt sound
            actor_speak_default_state(player_with_lang_muffle_random("sanity"), psy_volume,
                    sanity_pause, 2000)

        elseif arszi_psy.get_psy_health() < 1.0 and psy_volume > 0 then
            -- new psy-hurt sound (weak psy)
            actor_speak_default_state(player_with_lang_muffle_random("fear"), psy_volume,
                    fear_pause, 100) -- plays the psy wounded sound

        elseif db.actor.power < 0.10 and sprint_volume > 0 and hurt_volume < sprint_volume and hurt_pause > sprint_pause then
            -- exhaustion state will only play if it has both longer pause and higher volume than the hurt sound
            actor_speak_default_state(player_with_lang_muffle_random("exhausted"),
                    sprint_volume, sprint_pause, 100) -- plays the exhausted sound

        elseif db.actor.health < 0.55 and hurt_volume > 0 then
            -- normal hurt state will play if everything else fails to meet the conditions
            actor_speak_default_state(player_with_lang_muffle_random("hurt"), hurt_volume,
                    hurt_pause, 100) -- plays the wounded sound

        elseif actor_status_thirst.get_water_deprivation(true) > 0.3 and thirst_volume > 0 then
            actor_speak_default_state(player_with_lang_muffle_random("thirst"),
                    thirst_volume, thirst_pause, 100)

        elseif db.actor:cast_Actor():conditions():GetSatiety() < 0.3 and satiety_volume > 0 then
            actor_speak_default_state(player_with_lang_muffle_random("hunger"),
                    satiety_volume, satiety_pause, 100) -- new satiety sound call, adjust filename and corresponding math factor

        elseif actor_status_sleep.get_sleep_deprivation(true) > 0 and sleep_volume > 0 then
            actor_speak_default_state(player_with_lang_muffle_random("sleepiness"),
                    sleep_volume, sleep_pause, 100)

        end
    end
end

local hit_timer1 = 0 -- this little fella will help us prevent pain sounds from playing non-stop in damaging areas
local last_health = 1 -- notes down the last health value between instances of area damage

function actor_on_before_hit(hitinfo, bone_id, flags)
    -- damage function, plays pain sounds (PLEASE DON'T PUT HIT SOUNDS HERE, CHARACTER PAIN ONLY)

    if not db.actor:alive() then
        return
    end -- don't play pain sounds if actor is already dead

    local hit_type = hitinfo and hitinfo.type
    if not (hitinfo and hit_type and hitinfo.power) then
        return
    end -- filters out info-less hits
    if (hit_type == hit.radiation or hit_type == hit.telepatic) then
        return
    end -- filters out radiation and psi damage

    -- all the code related to fixing area damage is pretty much spaghett, I'm honestly way too tired of this shit

    tg = time_global()
    if tg > hit_timer1 then
        -- prevents too many pain sounds from playing in a short succession
        local cooldown = nil

        if get_config("enable_pain_shouts") then
            if last_health < db.actor.health then
                last_health = (db.actor.health - 0.0001)
            end -- if player's health value is higher than whatever we last noted down - reset it
            local anims = { "hit_front", "hit_front_left", "hit_front_right" } -- a table of camera animations for hit punch
            if (hit_type == hit.burn or hit_type == hit.light_burn or hit_type == hit.chemical_burn) and
                    (last_health - db.actor.health) >= 0.1 then
                -- this checks for a specific threshold for "area" damage types
                if axr_companions.sound_checking() == true then
                    return
                end -- CHECKS IF VOICED COMMAND IS CURRENTLY PLAYED AND IF YES ,IT WILL STOP FUNCTION SO IT WILL NOT INTERRUPT ANY COMMAND
                if db.actor.health > 0.5 then
                    -- checks if the actor is over 50% of their full health
                    cooldown = 2000
                    actor_speak_with_priority_ignore_conditionals(player_with_lang_muffle_random("pain"), 1.0,
                            cooldown, 100)
                else
                    cooldown = 2500
                    actor_speak_with_priority_ignore_conditionals(player_with_lang_muffle_random("pain_bad"), 1.0,
                            cooldown, 100)
                end
                level.add_cam_effector("camera_effects\\" .. anims[math.random(#anims)] .. ".anm",
                        math.random(447555, 447999), false, "") -- if you use a generic camera punch effect, put it here
                last_health = db.actor.health -- saves player's health value for later use
                hit_timer1 = tg + 1000 -- sets the delay of one second before the next pain sound can be played if the damage type is usable as an area effect
            elseif (hit_type == hit.shock or hit_type == hit.strike or hit_type == hit.wound or hit_type ==
                    hit.fire_wound or hit_type == hit.explosion or hit_type == hit.wound_2) then
                -- this is for every other "non-area" damage type
                if axr_companions.sound_checking() == true then
                    return
                end -- CHECKS IF VOICED COMMAND IS CURRENTLY PLAYED AND IF YES ,IT WILL STOP FUNCTION SO IT WILL NOT INTERRUPT ANY COMMAND
                if db.actor.health > 0.5 then
                    cooldown = 2000
                    actor_speak_with_priority_ignore_conditionals(player_with_lang_muffle_random("pain"), 1.0,
                            cooldown, 100)
                else
                    cooldown = 2500
                    actor_speak_with_priority_ignore_conditionals(player_with_lang_muffle_random("pain_bad"), 1.0,
                            cooldown, 100)
                end
                --			level.add_cam_effector( "camera_effects\\" .. anims[math.random(#anims)] .. ".anm", math.random(447555, 447999), false, "" ) --if you use a generic camera punch effect, put it here
                hit_timer1 = tg + 125 -- sets the delay of 1/8th of a second before the next pain sound can be played if the damage type is only used in hits
            end
        else
            -- filters disabled pain sounds from MCM
            hit_timer1 = tg + 3500 -- sets the delay to be equal to delay from actor_speak_about_hit
        end

        if cooldown ~= nil then
            printf("hit by %s, cooldown: %s, timer %s", hit_type, cooldown, hit_timer1)
            CreateTimeEvent("varefined", "before_hit_comment", (cooldown + 150) / 1000, function(hit_type)
                actor_speak_about_hit(hit_type)
                return true
            end, hit_type)
        end
    end

    --	level.add_pp_effector("amk_shoot.ppe",447554,false) --if you use a generic screen flash effect, put it here

    if is_actor_in_combat() and (hit_type == hit.fire_wound or hit_type == hit.wound) then
        -- if actor is in combat and was hit by a human or by a mutant, add combat intensity
        add_action_intensity(50, 0.5, 200)
    end

end

function actor_speak_about_hit(hit_type)
    local hit_type_string = gameplay_silent_kills.dtype[hit_type]
    actor_speak_default(player_with_lang_muffle_random(string.format("hit_by_%s", hit_type_string)), 1.0,
            3500, 100)
end

function actor_on_before_death(whoID, flags)
    -- death function, plays death sounds (DEATH SCREAMS AND WHELPS ONLY, NO BODY FALLING SOUNDS OR ANYTHING ELSE)

    axr_companions.sound_checking_stop() -- STOPS SOUND IF COMMAND FROM axr_companions.script IS CURRENTLY PLAYING
    actor_speak_with_priority_ignore_conditionals(player_with_lang_muffle_random("death"), 1.0, 9999, 100)

end

local already_commented_this_jam = false -- marker value, tells the code that this jam was already commented on

function actor_on_weapon_jammed(wpn)
    -- (EDITED FUNCTION - ADDED MORE CALLBACKS) plays responses to weapon jams

    if already_commented_this_jam == true then
        return
    end -- don't attempt to play the sound if it has been processed already

    already_commented_this_jam = true -- marks that we already tried to respond to this jam

    if db.actor:is_talking() then
        return
    end
    if axr_companions.sound_checking() == true then
        return
    end -- CHECKS IF VOICED COMMAND IS CURRENTLY PLAYED AND IF YES ,IT WILL STOP FUNCTION SO IT WILL NOT INTERRUPT ANY COMMAND
    if not get_config("enable_on_weapon_jam_shouts") then
        return
    end -- filters disabled jam shouts from MCM
    if is_actor_in_combat() == true then
        -- PLAYS LOUD RESPONSES TO GUN JAMS IF ACTOR IS IN COMBAT (INNER COMBAT PERIMETER) ,DIFFERENT SHOUTS FOR SQUAD ,DIFFERENT IF HE IS ALONE OR SQUAD IS OUT OF HEARING DISTANCE
        actor_speak_squad_near(player_with_lang_muffle_random("gun_jam_squad"), 1.0,
                2500, 100)
        actor_speak_squad_can_hear(player_with_lang_muffle_random("gun_jam_squad"), 1.0,
                2500, 100)
        actor_speak_squad_out(player_with_lang_muffle_random("gun_jam_alone"), 1.0,
                2500, 100)
        add_action_intensity(30, 0.5, 125)
    elseif outer_combat_checker() == true and combat_intensity > combat_medium_threshold then
        -- FOR ACTOR IN COMBAT (OUTER COMBAT PERIMETER) PLAYS LOUD RESPONSES WITH 50% CHANCE IF COMBAT INTENSITY IS AT LEAST ON STATE2
        actor_speak_default(player_with_lang_muffle_random("gun_jam_alone"), 1.0,
                2500, 50)
    elseif outer_combat_checker() == true then
        -- FOR ACTOR IN COMBAT (OUTER COMBAT PERIMETER) PLAYS CALM RESPONSES WITH 50% IF COMBAT INTENSITY IS ONLY ON STATE1
        actor_speak_default(player_with_lang_muffle_random("gun_jam"), 1.0, 2500, 50)
    elseif not (is_actor_in_combat()) and not (outer_combat_checker()) then
        -- IF ACTOR IS NOT IN COMBAT AT ALL ,IT WILL PLAYS ONLY CALM RESPONSES TO GUN JAMS AND WITH 50% CHANCE TO PLAY (SAME LIKE FOR COMBAT IN OUTER COMBAT PERIMETER WITH COMBAT INTENSITY ON STATE1)
        actor_speak_default(player_with_lang_muffle_random("gun_jam"), 1.0, 2500, 50)
    end

end

function actor_on_weapon_reload(wpn, ammo_total)
    -- calls out reloads

    already_commented_this_jam = false -- clear the marker, actor is fixing the jam

    if db.actor:is_talking() then
        return
    end
    if axr_companions.sound_checking() == true then
        return
    end -- CHECKS IF VOICED COMMAND IS CURRENTLY PLAYED AND IF YES ,IT WILL STOP FUNCTION SO IT WILL NOT INTERRUPT ANY COMMAND
    if not get_config("enable_on_weapon_reload_shouts") then
        return
    end -- filters disabled reload shouts from MCM
    if is_actor_in_combat() == true then
        -- only plays reload shouts if actor is in combat ,has a squad IN HEARING DISTANCE AND IF ENEMIES ARE IN INNER COMBAT PERIMETER
        actor_speak_squad_near(player_with_lang_muffle_random("reloading"), 1.0, 2500, 100)
        actor_speak_squad_can_hear(player_with_lang_muffle_random("reloading"), 1.0, 2500, 100)
        add_action_intensity(40, 0.5, 175)
    end

end

local actor_weapon = 0 -- is set later
local actor_weapon_name = "none" -- is set later
local actor_weapon_state = 0 -- is set later
local next_throw_callout = 0 -- is set later

function on_key_release(key)
    -- (EDITED FUCTION - ADDED MORE CALLBACKS) grenade throw callout function

    if time_global() < next_throw_callout then
        return
    end -- checks for the grenade throw pause

    if ((key == DIK_keys["MOUSE_1"]) or (key == DIK_keys["MOUSE_2"])) then
        -- only runs if LMB (auto-throw) or RMB (regulated throw) is pressed
        actor_weapon = db.actor:active_item() -- gets whatever weapon actor is currently using
        if not actor_weapon then
            return
        end -- prevents the code from running if there's no weapon, it'll cause an engine crash otherwise
        actor_weapon_name = actor_weapon:name() -- gets the weapon name
        actor_weapon_state = actor_weapon:get_state() -- gets what the weapon is doing right now
        if (actor_weapon_state == 5 or actor_weapon_state == 6 or actor_weapon_state == 7 or actor_weapon_state == 1) -- the weapon is being: pin-pulled, thrown, "reloaded"
                and (string.find(actor_weapon_name, "grenade_rgd") or string.find(actor_weapon_name, "grenade_f") or
                string.find(actor_weapon_name, "grenade_gd")) -- the list of valid nades for the callouts (I'd do a table but I don't really know how they work in this engine and I'm not feeling like spending time on that)
        then
            next_throw_callout = time_global() + 5000 -- sets the pause of five seconds before the next callout
            add_action_intensity(75, 0.5, 500)
            if db.actor:is_talking() then
                return
            end
            if not (is_actor_in_combat()) and not (outer_combat_checker()) then
                return
            end -- IF ACTOR IS NOT IN COMBAT (FOR BOTH PERIMETERS) IT WILL STOP FUNCTION
            if axr_companions.sound_checking() == true then
                return
            end -- CHECKS IF VOICED COMMAND IS CURRENTLY PLAYED AND IF YES ,IT WILL STOP FUNCTION SO IT WILL NOT INTERRUPT ANY COMMAND
            if not get_config("enable_on_grenade_throw_shouts") then
                return
            end -- filters disabled grenade thrown shouts from MCM
            if is_actor_in_combat() == true then
                -- ACTOR IN COMBAT IN INNER PERIMETER
                actor_speak_squad_near(player_with_lang_muffle_random("grenade_throw_squad"),
                        1.0, 3000, 100) -- IF ACTOR HAVE A SQUAD AND COMPANIONS ARE NOT FARTHER THAN 60m (SO THEY ARE IN DANGER ZONE) ,PLAYS WARNING AND INFORMATIVE GRENADE THROW CALLOUTS ADDRESSED TO COMPANIONS
                actor_speak_squad_can_hear(player_with_lang_muffle_random("grenade_throw_squad"),
                        1.0, 3000, 100)
                actor_speak_squad_out(player_with_lang_muffle_random("grenade_throw"),
                        1.0, 3000, 100) -- IF ACTOR IS NOT IN SQUAD OR COMPANIONS ARE FARTHER THAN 60m (SO THERE IS NO REASON TO WARNING THEM) ,PLAYS ANGRY GRENADE THROW CALLOUTS ADDRESSED TO ENEMIES
            elseif outer_combat_checker() == true then
                -- ACTOR IN COMBAT IN OUTER PERIMETER
                actor_speak_squad_near(player_with_lang_muffle_random("grenade_throw_squad"),
                        1.0, 3000, 100) -- IF ACTOR HAVE A SQUAD AND COMPANIONS ARE NOT FARTHER THAN 60m ,PLAYS WARNING AND INFORMATIVE GRENADE THROW CALLOUTS ADDRESSED TO COMPANIONS
                actor_speak_squad_can_hear(player_with_lang_muffle_random("grenade_throw_squad"),
                        1.0, 3000, 100)
            end
        end
        -- DEBUG--		SetHudMsg("Weapon Name: " .. actor_weapon_name .. ", Weapon State: " .. actor_weapon:get_state()) --displays what weapon is the actor using and at what state when LMB or RMB is released
    end

end

---------------------------------------------
-- FROM HERE STARTS INTERACTIVE COMMENTS PART
---------------------------------------------

-- CONDITION CHECKERS
----------------------

function hurt_bad_cond()
    -- CONDITION CHECKER FOR BADLY INJURED STATE ,MEANS PRETTY LOW ON HEALTH
    if db.actor.health <= 0.25 then
        return true
    else
        return false
    end
end

function hurt_cond()
    -- CONDITION CHECKER FOR INJURED STATE ,MEANS HEALTH IS LESS THAN HALF ,BUT NOT AS LOW AS AT BADLY INJURED STATE
    if db.actor.health > 0.25 and db.actor.health <= 0.5 then
        return true
    else
        return false
    end
end

function bleed_cond()
    -- CONDITION CHECKER FOR BLEEDING STATE ,MEANS ACTOR IS BLEEDING BUT HEALTH IS MORE THAN HALF (HURT STATES HAS PRIORITY)
    if db.actor.bleeding >= 0.1 and db.actor.health > 0.5 then
        return true
    else
        return false
    end
end

function tired_cond()
    -- CONDITION CHECKER FOR STAMINA ,TRUE MEANS STAMINA IS LESS THAN HALF BUT SOUND FOR THIS STATE WILL BE PLAYED ONLY IF ACTOR IS NOT COUNTED AS INJURED ,BADLY INJURED OR BLEEDING
    if db.actor.power < 0.5 and not (bleed_cond()) and not (hurt_bad_cond()) and not (hurt_cond()) then
        return true
    else
        return false
    end
end

function ok_cond()
    -- OK (RELATIVELY) CONDITION CHECKER ,TRUE MEANS ACTOR IS NOT COUNTED AS INJURED OR BADLY INJURED OR BLEEDING OR TIRED
    if db.actor.health > 0.5 and db.actor.bleeding < 0.1 and db.actor.power >= 0.5 then
        return true
    else
        return false
    end
end

-- INTERACTIVE COMMENTS ON BUTTON
--------------------------------------

function interactive_comments_on_button(key)

    -------------------------------------------------------------------------------------------
    -- HERE IN BELOW LINE YOU CAN CHANGE INTERACTIVE BUTTON FOR WHATEVER YOU WANT ,DEFAULT IS V
    -------------------------------------------------------------------------------------------
    if (key == get_config("comments_shouts_key")) then
        -- RUNS IF CERTAIN KEY IS PRESSED
        if db.actor:is_talking() then
            return
        end
        if not db.actor:alive() then
            return
        end -- IF ACTOR IS DEAD ALREADY IT WILL STOP FUNCTION
        if axr_companions.sound_checking() == true then
            return
        end -- CHECKS IF VOICED COMMAND IS CURRENTLY PLAYED AND IF YES ,IT WILL STOP FUNCTION SO IT WILL NOT INTERRUPT ANY COMMAND
        if is_actor_in_combat() == true then
            -- IF ACTOR IS TARGETED BY ENEMY IN INNER PERIMETER IT WILL PLAYS ,FOR SQUAD IN HEARING DISTANCE INFORMATIVE BUT LOUD AND COCKY RESPONSES ,WITHOUT SQUAD OR WITH SQUAD TOO FAR JUST SIMPLE LOUD INVECTIVES
            actor_speak_squad_near(button_comments_with_lang_muffle_random("Enemy_squad"), 1.0,
                    3000, 100)
            actor_speak_squad_can_hear(button_comments_with_lang_muffle_random("Enemy_squad"), 1.0,
                    3000, 100)
            actor_speak_squad_out(player_with_lang_muffle_random("kill_confirm_common_state1"), 1.0,
                    3500, 100)
        elseif outer_combat_checker() == true then
            -- IF ACTOR IS TARGETED BY ENEMY FROM OUTER PERIMETER IT WILL PLAYS ,FOR SQUAD IN HEARING DISTANCE LOUD INFORMATIVE BUT NOT COCKY RESPONSES ,WITHOUT SQUAD OR WITH SQUAD TOO FAR JUST SIMPLE INVECTIVES BUT NOT LOUD
            actor_speak_squad_near(button_comments_with_lang_muffle_random("EnemyFar_squad"),
                    1.0, 2000, 100)
            actor_speak_squad_can_hear(button_comments_with_lang_muffle_random("EnemyFar_squad"),
                    1.0, 2000, 100)
            actor_speak_squad_out(button_comments_with_lang_muffle_random("Enemy"), 1.0,
                    2000, 100)
        elseif not (is_actor_in_combat()) and not (outer_combat_checker()) then
            -- IF ACTOR IS NOT TARGETED BY ENEMY FROM INNER OR OUTER COMBAT PERIMETER ,CONDITION COMMENTS WILL BE PLAYED
            if hurt_bad_cond() == true then
                -- IF ACTOR IS BADLY INJURED IT WILL PLAY DIFFERENT COMMENT FOR SQUAD UP TO NEAR DISTANCE (ADDRESSED TO COMPANIONS) AND DIFFERENT IF HE IS ALONE ,OR SQUAD IS NOT CLOSE ENOUGH
                actor_speak_squad_near(button_comments_with_lang_muffle_random("HurtBad_SquadNear"),
                        1.0, 3500, 100)
                actor_speak_squad_can_hear(button_comments_with_lang_muffle_random("HurtBad"), 1.0,
                        3500, 100)
                actor_speak_squad_out(button_comments_with_lang_muffle_random("HurtBad"), 1.0,
                        3500, 100)
            elseif hurt_cond() == true then
                -- SAME AS BEFORE ,EXCEPT ACTOR IS NOT BADLY INJURED BUT STILL INJURED
                actor_speak_squad_near(button_comments_with_lang_muffle_random("Hurt_SquadNear"),
                        1.0, 3500, 100)
                actor_speak_squad_can_hear(button_comments_with_lang_muffle_random("Hurt"),
                        1.0, 3500, 100)
                actor_speak_squad_out(button_comments_with_lang_muffle_random("Hurt"),
                        1.0, 3500, 100)
            elseif bleed_cond() == true then
                -- SAME AS BEFORE ,EXCEPT ACTOR IS BLEEDING ,BUT NOT INJURED OR BADLY INJURED
                actor_speak_squad_near(button_comments_with_lang_muffle_random("Bleed_SquadNear"),
                        1.0, 3000, 100)
                actor_speak_squad_can_hear(button_comments_with_lang_muffle_random("Bleed"),
                        1.0, 3500, 100)
                actor_speak_squad_out(button_comments_with_lang_muffle_random("Bleed"),
                        1.0, 3500, 100)
            elseif tired_cond() == true then
                -- SAME AS BEFORE ,EXCEPT ACTOR IS TIRED ,BUT NOT INJURED OR BADLY INJURED OR BLEEDING
                actor_speak_squad_near(button_comments_with_lang_muffle_random("Tired_SquadNear"),
                        1.0, 3500, 100)
                actor_speak_squad_can_hear(button_comments_with_lang_muffle_random("Tired"),
                        1.0, 2500, 100)
                actor_speak_squad_out(button_comments_with_lang_muffle_random("Tired"),
                        1.0, 2500, 100)
            elseif ok_cond() == true then
                -- IF ACTOR IS NOT INJURED OR BADLY INJURED OR BLEEDING OR TIRED (SIMPLY PUT ,HE IS RELATIVELY OK) ,IT WILL PLAY MUMBLE COMMENT ,DIFFERENT FOR SQUAD UP TO NEAR DISTANCE (ADDRESSED TO COMPANIONS) AND DIFFERENT IF HE IS ALONE ,OR SQUAD IS NOT CLOSE ENOUGH
                actor_speak_squad_near(button_comments_with_lang_muffle_random("Mumble_SquadNear"),
                        1.0, 3500, 100)
                actor_speak_squad_can_hear(button_comments_with_lang_muffle_random("Mumble"),
                        1.0, 3500, 100)
                actor_speak_squad_out(button_comments_with_lang_muffle_random("Mumble"),
                        1.0, 3500, 100)
            end
        end
    end
end

local talking_to_unique_npc_story_id = false
function GUI_on_show(name, path)
    if name ~= "Dialog" then
        return
    end

    local npc = get_speaker(true, true)
    if not npc then
        return
    end

    talking_to_unique_npc_story_id = get_object_story_id(npc:id()) or nil
    if not talking_to_unique_npc_story_id then
        start_dialog_with_regular_npc()
        return
    end

    start_dialog_with_unique_npc(talking_to_unique_npc_story_id)
end

function start_dialog_with_unique_npc(story_id)
    dialog_with_unique_npc(story_id, "start_unique")
end

function end_dialog_with_unique_npc(story_id)
    dialog_with_unique_npc(story_id, "end_unique")
end

function dialog_with_unique_npc(story_id, unique_category)
    if story_id == nil then
        return
    end

    local unique_npc_category = unique_category .. "_" .. story_id

    actor_speak_default_ignore_conditionals(dialogs_with_lang_muffle(choose_random_category(unique_category, unique_npc_category)), 1.0, 3500, 100)
end

function choose_random_category(...)
    local categories = { ... }
    local total_lines = 0
    local lines = {}
    for _, category in ipairs(categories) do
        local count = get_lines_amount_for_line_for_current_lang(category)
        lines[#lines + 1] = count
        total_lines = total_lines + count
    end

    local random = math.random(1, total_lines)
    local cumulative = 0
    for i, count in ipairs(lines) do
        cumulative = cumulative + count
        if random <= cumulative then
            printf("Chose category %s with %s lines (random number was %s)", categories[i], count, random)
            return categories[i]
        end
    end

    return "none"
end

function GUI_on_hide(name, path)
    if name ~= "Dialog" then
        return
    end

    if not talking_to_unique_npc_story_id then
        end_dialog_with_regular_npc()
        return
    end

    end_dialog_with_unique_npc(talking_to_unique_npc_story_id)
    talking_to_unique_npc_story_id = nil
end

function start_dialog_with_regular_npc()
    actor_speak_default_ignore_conditionals(dialogs_with_lang_muffle("start_regular"), 1.0, 3500, 100)
end

function end_dialog_with_regular_npc()
    actor_speak_default_ignore_conditionals(dialogs_with_lang_muffle("end_regular"), 1.0, 3500, 100)
end

--------------------------------------
-- INTERACTIVE COMMENTS PART ENDS HERE
--------------------------------------

function random_shouts(key)
    if (key == get_config("random_shouts_key")) then
        if not db.actor:alive() then
            return
        end
        if db.actor:is_talking() then
            return
        end
        if axr_companions.sound_checking() == true then
            return
        end
        actor_speak_default(random_shout_with_lang_muffle_random("random"), 1.0,
                3500, 100) -- Voiced Actor Refined edit
    end
end

--------------------------------------
-- RANDOM SHOUTS PART ENDS HERE
--------------------------------------

function on_game_start()
    -- lets the engine know we want these function to run when certain things happen
    RegisterScriptCallback("actor_on_update", actor_on_update) -- runs every tick
    RegisterScriptCallback("actor_on_before_hit", actor_on_before_hit) -- runs right before the actor gets damaged
    RegisterScriptCallback("actor_on_before_death", actor_on_before_death) -- runs right before the actor dies
    RegisterScriptCallback("actor_on_weapon_jammed", actor_on_weapon_jammed) -- runs when actor's weapon jams
    RegisterScriptCallback("actor_on_weapon_reload", actor_on_weapon_reload) -- runs when actor reloads their weapon
    RegisterScriptCallback("on_key_release", on_key_release) -- runs when any key is released
    RegisterScriptCallback("on_key_press", interactive_comments_on_button) -- RUNS WHEN CERTAIN KEY IS PRESSED ,IN THIS CASE IT IS FOR INTERACTIVE COMMENTS ON BUTTON
    RegisterScriptCallback("on_key_press", random_shouts) -- RUNS WHEN CERTAIN KEY IS PRESSED ,IN THIS CASE IT IS FOR RANDOM SHOUTS ON BUTTON
    RegisterScriptCallback("npc_on_death_callback", npc_on_death_callback) -- runs when a human (NOT ACTOR) dies
    RegisterScriptCallback("monster_on_death_callback", monster_on_death_callback) -- runs when a mutant dies
    RegisterScriptCallback("npc_on_hit_callback", npc_on_hit_callback) -- runs when a human (NOT ACTOR) is hit
    RegisterScriptCallback("monster_on_hit_callback", monster_on_hit_callback) -- runs when a mutant is hit
    RegisterScriptCallback("GUI_on_show", GUI_on_show) -- runs when a mutant is hit
    RegisterScriptCallback("GUI_on_hide", GUI_on_hide) -- runs when a mutant is hit
    init_languages()
end